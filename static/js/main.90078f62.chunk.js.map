{"version":3,"sources":["chartparser.js","runparser.js","grammars/vgGrammar.ts","dmAppointmentVG.ts","index.tsx","srgs.js"],"names":["LOG","str","clone","obj","temp","constructor","key","isEmpty","ob","i","hasOwnProperty","Chart","numberOfWords","this","passives","Array","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","content","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","_string","toString","ActiveEdge","rest","rules","text","parse","words","grammar","root","filter","$root","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","min","max","oneof","eval","undefined","ruleref","position","leftCorners","pop","active","join","ref","passive","loadGrammar","dom","DOMParser","parseFromString","ActiveXObject","doc","XML","newDocument","loadXML","url","encodeURIComponent","request","XMLHttpRequest","open","send","responseXML","parseXML","getElementsByTagName","getAttribute","xrules","r","xrule","processRuleExpansions","xitems","childNodes","rule","nodeType","textContent","trim","split","nodeName","uri","repeat","parseInt","Infinity","console","log","vgGrammar","getObjects","input","gram","result","action1","object1","action2","object2","parseForm","say","_context","type","value","actions","cancel","boolgrammar","yes","no","dmMachine","initial","states","init","on","CLICK","createAppointment","RECOGNISED","target","cond","context","recResult","MAXSPEECH","counter","hist","who","person","day","time","assign","prompt","entry","ENDSPEECH","ask","delay","id","nomatch","allday","schedule_meeting_allday","schedule_meeting","maxspeech1","maxspeech2","maxspeech3","help","action","object","inspect","iframe","machine","Machine","dm","asrtts","idle","LISTEN","SPEAK","event","ttsAgenda","recognising","exit","ASRRESULT","count","progress","match","speaking","recLogResult","test","logIntent","nluData","intent","name","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","listen","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","body","background","ttsStart","effect","ttsCancel","current","onClick","nluRequest","fetch","Request","proxyurl","method","headers","then","data","json","rootElement","getElementById","ReactDOM","Grammar","VOID","OneOf","NULL","GARBAGE","$check","checkSequenceExpansion","err","throwRuleError","Ref","RefClass","Tag","tag","TagClass","alternatives","OneOfClass","Repeat","sequence","RepeatClass","message","error","TypeError","String","checkExpansion","prototype","Number"],"mappings":"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","file":"static/js/main.90078f62.chunk.js","sourcesContent":["//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/\n\n//////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str) {\n    //console.log(\"\" + str);\n}\n\nimport * as SRGS from './srgs'\n\n//////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\nfunction clone(obj) {\n    if (obj == null || typeof (obj) != 'object') {\n        return obj;\n    }\n    var temp = new obj.constructor();\n    for (var key in obj) {\n        temp[key] = clone(obj[key]);\n    }\n    return temp;\n}\n\n\nfunction isEmpty(ob) {\n    for (var i in ob) { if (ob.hasOwnProperty(i)) { return false; } }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\nfunction Chart(numberOfWords) {\n    this.numberOfWords = numberOfWords;\n    this.passives = new Array(numberOfWords);\n    this.actives = new Array(numberOfWords);\n    for (var i = 0; i <= numberOfWords; i++) {\n        this.passives[i] = {};\n        this.actives[i] = {};\n    }\n\n    // Chart.add(edge)\n    // add the edge to the chart, return true if the chart was changed \n    // (i.e. if the chart didn't already contain the edge)\n    this.add = function add(edge) {\n        var subchart, cat;\n        if (edge.isPassive) {\n            subchart = this.passives[edge.start];\n            cat = edge.lhs;\n        } else {\n            subchart = this.actives[edge.end];\n            cat = edge.next.content;\n        }\n        if (!(cat in subchart)) {\n            subchart[cat] = {};\n        }\n        if (edge in subchart[cat]) {\n            return false;\n        } else {\n            subchart[cat][edge] = edge;\n            return true;\n        }\n    }\n\n    // Chart.resultsForRule(lhs, start, end)\n    // return all parse results for the given lhs, start, and end\n    //  - start, end are optional; defaults to 0, numberOfWords\n    this.resultsForRule = function resultsForRule(lhs, start, end) {\n        start = start || 0;\n        end = end || numberOfWords;\n        var results = [];\n        var finalEdges = this.passives[start][lhs];\n        for (var i in finalEdges) {\n            if (finalEdges[i].end == end) {\n                results.push(finalEdges[i].out);\n            }\n        }\n        return results;\n    }\n\n    // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n    // return an array of all (passive/active) edges in the chart\n    this.allEdges = function allEdges() {\n        return this.allPassiveEdges().concat(this.allActiveEdges());\n    }\n    this.allPassiveEdges = function allPassiveEdges() {\n        var edges = [];\n        for (var i in this.passives)\n            for (var j in this.passives[i])\n                for (var k in this.passives[i][j])\n                    edges.push(this.passives[i][j][k]);\n        return edges;\n    }\n    this.allActiveEdges = function allActiveEdges() {\n        var edges = [];\n        for (var i in this.actives)\n            for (var j in this.actives[i])\n                for (var k in this.actives[i][j])\n                    edges.push(this.actives[i][j][k]);\n        return edges;\n    }\n\n    // Chart.statistics()\n    // return the number of edges in the chart\n    this.statistics = function statistics() {\n        var passives = this.allPassiveEdges().length;\n        var actives = this.allActiveEdges().length;\n        return { nrEdges: passives + actives, nrPassiveEdges: passives, nrActiveEdges: actives };\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\n\nfunction PassiveEdge(start, end, lhs, out) {\n    this.start = start;\n    this.end = end;\n    this.lhs = lhs;\n    this.out = out;\n    this.isPassive = true;\n\n    var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\n    this._string = str;\n    this.toString = function toString() { return this._string; }\n}\n\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\n    this.start = start;\n    this.end = end;\n    this.lhs = lhs;\n    this.next = next;\n    this.rest = rest;\n    this.out = out;\n    this.rules = rules;\n    this.text = text;\n    this.isPassive = false;\n\n    var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next +\n        \", \" + rest + \" := \" + out + \" <- \" + rules;\n    this._string = str;\n    this.toString = function toString() { return this._string; }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\nexport function parse(words, grammar, root, filter) {\n    if (!root) {\n        root = grammar.$root;\n    }\n    var chart = new Chart(words.length);\n    var agenda = [];\n\n    var leftCornerFilter;\n    if (filter == undefined) {\n        leftCornerFilter = function () { return true };\n    } else {\n        leftCornerFilter = function leftCornerFilter(ruleref, position) {\n            var leftCorners = filter[ruleref];\n            return leftCorners ? words[position] in leftCorners : true;\n        }\n    }\n\n    // add an edge to the chart and the agenda, if it does not already exist\n    function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\n        var edge;\n        if (rhs.length > 0) {\n            var next = rhs[0];\n            var rest = rhs.slice(1);\n            switch (next.constructor) {\n\n                case Array:\n                    // the next symbol is a sequence\n                    addToChart(inference + \",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\n                    return;\n\n                case SRGS.RepeatClass:\n                    // the next symbol is a repetition\n                    var min = next.min;\n                    var max = next.max;\n                    // skip repeat \n                    if (min <= 0) {\n                        addToChart(inference + \",SKIP\", start, end, lhs, rest, out, rules, text);\n                    }\n                    // repeat \n                    if (max > 0) {\n                        var content = next.content;\n                        var rhs = (max == 1 ? [content] : [content, SRGS.Repeat(min ? min - 1 : min, max - 1, content)]);\n                        addToChart(inference + \",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\n                    }\n                    return;\n\n                case SRGS.OneOfClass:\n                    // the next symbol is a disjunction\n                    var oneof = next.content;\n                    for (var i in oneof) {\n                        var rhs = oneof[i].concat(rest);\n                        addToChart(inference + \",ONEOF\", start, end, lhs, rhs, out, rules, text);\n                    }\n                    return;\n\n                case SRGS.TagClass:\n                    // the next symbol is a semantic action\n                    out = clone(out);\n                    rules = clone(rules);\n                    eval(next.content);\n                    addToChart(inference + \",TAG\", start, end, lhs, rest, out, rules, text);\n                    return;\n            }\n\n            edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\n        } else {\n            edge = new PassiveEdge(start, end, lhs, out);\n        }\n\n        // try to add the edge; if successful, also add it to the agenda\n        if (chart.add(edge)) {\n            LOG(\"+ \" + inference + \": \" + edge);\n            agenda.push(edge);\n        }\n    }\n\n    // seed the agenda with the starting rule\n    addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\n\n    // main loop\n    while (agenda.length > 0) {\n        var edge = agenda.pop();\n        var start = edge.start;\n        var end = edge.end;\n        var lhs = edge.lhs;\n        var next = edge.next;\n        LOG(edge);\n\n        if (edge.isPassive) {\n            // combine\n            var actives = chart.actives[start][lhs];\n            for (var i in actives) {\n                var active = actives[i];\n                var rules = clone(active.rules);\n                var text = active.text;\n                text[edge.lhs] = words.slice(start, end).join(\" \");\n                if (typeof edge.out == 'object' && isEmpty(edge.out)) {\n                    rules[edge.lhs] = text[edge.lhs];\n                } else {\n                    rules[edge.lhs] = clone(edge.out);\n                }\n                addToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\n            }\n\n        } else if (next.constructor == SRGS.RefClass) {\n            var ref = next.content;\n            // combine\n            var passives = chart.passives[end][ref];\n            for (var i in passives) {\n                var passive = passives[i];\n                var rules = clone(edge.rules);\n                var text = edge.text;\n                rules[passive.lhs] = clone(passive.out);\n                text[passive.lhs] = passive.text;\n                addToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\n            }\n            // predict\n            if (ref in grammar) {\n                if (leftCornerFilter(ref, end)) {\n                    addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\n                }\n            }\n\n        } else if (next == words[end]) {\n            // scan\n            addToChart(\"SCAN\", start, end + 1, lhs, edge.rest, edge.out, edge.rules, edge.text);\n        }\n    }\n\n    return chart;\n}\n","//\n//  runparser.js\n//\n/*\n  The author or authors of this code dedicate any and all \n  copyright interest in this code to the public domain.\n*/\n\n\n// helper functions for the parser demo\n\nimport * as SRGS from './srgs'\n\nfunction getElement(id) {\n    return document.getElementById(id);\n}\n\nfunction appendElement(parent, element, text) {\n    var elem = document.createElement(element);\n    if (text)\n        elem.appendChild(document.createTextNode(text));\n    parent.appendChild(elem);\n    return elem\n}\n\nfunction runParser(input) {\n    var resultsDiv = getElement(\"results\");\n    resultsDiv.innerHTML = \"\";\n    var maybeFilter;\n    if (getElement(\"usefilter\") && getElement(\"usefilter\").checked) {\n        maybeFilter = filter;\n        appendElement(resultsDiv, \"EM\", \"Using left-corner filter\");\n    }\n    var startTime = new Date();\n    var parseChart = parse(input, grammar, grammar.$root, maybeFilter);\n    var parseTime = new Date() - startTime;\n    var parseResults = parseChart.resultsForRule(grammar.$root);\n\n    console.log(parseResults[0]);\n\n    if (parseResults) {\n        for (var i in parseResults) {\n            resultsDiv.innerHTML += display(parseResults[i], \"\");\n        }\n    } else {\n        appendElement(resultsDiv, \"P\", \"No results found!\");\n    }\n\n    /*\n      if (parseResults) { \n        var resultList = appendElement(resultsDiv, \"OL\");\n        for (var i in parseResults) \n          appendElement(resultList, \"LI\", JSON.stringify(parseResults[i]));\n      } else {\n        appendElement(resultsDiv, \"P\", \"No results found!\");\n      }\n    */\n    var statistics = parseChart.statistics()\n    appendElement(resultsDiv, \"P\", \"Chart size: \" + statistics.nrEdges + \" edges\" +\n        \" (\" + statistics.nrPassiveEdges + \" passive)\");\n    appendElement(resultsDiv, \"P\", \"Parse time: \" + parseTime + \" ms\" +\n        \" (\" + (parseTime / statistics.nrEdges).toFixed(2) + \" ms/edge)\");\n}\n\nfunction runWordParser() {\n    runParser(getElement(\"input\").value.split(/\\s+/));\n}\n\nfunction runCharacterParser() {\n    runParser(getElement(\"input\").value.split(\"\"));\n}\n\nexport function loadGrammar(str) {\n    var dom = parseXML(str);\n    var root = dom.getElementsByTagName(\"grammar\")[0].getAttribute(\"root\");\n    var grammar = new SRGS.Grammar(root);\n    var xrules = dom.getElementsByTagName(\"rule\");\n    for (var r = 0; r < xrules.length; r++) {\n        var xrule = xrules[r];\n        var id = xrule.getAttribute(\"id\");\n        grammar[id] = processRuleExpansions(xrule);\n    }\n    return grammar;\n}\n\nfunction processRuleExpansions(xrule) {\n    var xitems = xrule.childNodes;\n    var rule = [];\n    for (var i = 0; i < xitems.length; i++) {\n        if (xitems[i].nodeType == 3) {\n            var str = xitems[i].textContent.trim();\n            if (str != \"\") {\n                rule.push(str.split(/ +/));\n            }\n        } else if (xitems[i].nodeType == 1) {\n            if (xitems[i].nodeName == \"token\") {\n                rule.push(SRGS.Tag(xitems[i].textContent));\n            } else if (xitems[i].nodeName == \"ruleref\") {\n                var uri = xitems[i].getAttribute(\"uri\");\n                rule.push(SRGS.Ref(uri.slice(1)));\n            } else if (xitems[i].nodeName == \"tag\") {\n                rule.push(SRGS.Tag(xitems[i].textContent.trim()));\n            } else if (xitems[i].nodeName == \"one-of\") {\n                rule.push(SRGS.OneOf(processRuleExpansions(xitems[i])));\n            } else if (xitems[i].nodeName == \"item\") {\n                var repeat = xitems[i].getAttribute(\"repeat\");\n                if (!repeat) {\n                    rule.push(processRuleExpansions(xitems[i]));\n                } else {\n                    var r = repeat.split(\"-\");\n                    var min = parseInt(r[0]);\n                    var max = parseInt(r[1]);\n                    max = (max) ? max : Infinity;\n                    rule.push(SRGS.Repeat(min, max, processRuleExpansions(xitems[i])));\n                }\n            } else {\n                console.log(xitems[i]);\n            }\n        }\n    }\n    return rule;\n}\n\nfunction parseXML(text) {\n    if (typeof DOMParser != \"undefined\") {\n        // Mozilla, Firefox, and related browsers\n        return (new DOMParser()).parseFromString(text, \"application/xml\");\n    }\n    else if (typeof ActiveXObject != \"undefined\") {\n        // Internet Explorer.\n        var doc = XML.newDocument();  // Create an empty document\n        doc.loadXML(text);            // Parse text into it\n        return doc;                   // Return it\n    }\n    else {\n        // As a last resort, try loading the document from a data: URL\n        // This is supposed to work in Safari. Thanks to Manos Batsis and\n        // his Sarissa library (sarissa.sourceforge.net) for this technique.\n        var url = \"data:text/xml;charset=utf-8,\" + encodeURIComponent(text);\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", url, false);\n        request.send(null);\n        return request.responseXML;\n    }\n};","export const vgGrammar = `\n<grammar root=\"home\">\n\n<rule id=\"home\">\n\n<item repeat=\"0-1\">with</item>\n\n<item repeat=\"0-1\"><ruleref uri=\"#person\"/>\n<tag>out.person=rules.person;</tag></item>\n\n<item repeat=\"0-1\">on</item>\n\n<item repeat=\"0-1\"><ruleref uri=\"#day\"/>\n<tag>out.day=rules.day;</tag></item>\n\n<item repeat=\"0-1\">at</item>\n\n<item repeat=\"0-1\"><ruleref uri=\"#time\"/>\n<tag>out.time=rules.time;</tag></item>\n\n<item repeat=\"0-1\">o'clock</item>\n\n <rule id=\"person\"> \n<one-of> \n<item> Monica <tag> out = 'Monica Geller'; \n</tag></item> \n<item> Rachel <tag> out = 'Rachel Green'; \n</tag></item>\n<item> Joey <tag> out = 'Joey Tribbiani'; \n</tag></item> \n<item> Phoebe <tag> out = 'Phoebe Buffay'; \n</tag></item> \n<item> Ross <tag> out = 'Ross Geller'; \n</tag></item> \n<item> Chandler <tag> out = 'Chandler Bing'; \n</tag></item> \n </one-of> \n </rule>\n\n <rule id=\"day\"> \n<one-of> \n<item> Monday </item> \n<item> Tuesday </item>\n<item> Wednesday </item> \n<item> Thursday </item> \n<item> Friday </item> \n<item> Saturday </item> \n<item> Sunday </item> \n </one-of> \n </rule>\n\n <rule id=\"time\"> \n<one-of> \n<item> 10 <tag> out = '10:00'; \n</tag></item> \n<item> 11 <tag> out = '11:00'; \n</tag></item>\n<item> 12 <tag> out = '12:00'; \n</tag></item> \n<item> 1 <tag> out = '13:00'; \n</tag></item> \n<item> 2 <tag> out = '14:00'; \n</tag></item> \n<item> 3 <tag> out = '15:00'; \n</tag></item> \n<item> 4 <tag> out = '16:00'; \n</tag></item>\n<item> all day </item> \n </one-of> \n </rule>\n\n </grammar>\n`","import { MachineConfig, Action, assign, actions } from \"xstate\";\n\n// SRGS parser and example (logs the results to console on page load)\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { vgGrammar } from './grammars/vgGrammar'\n\nexport const getObjects = (input: any) => {\n    const gram = loadGrammar(vgGrammar)\n    const prs = parse(input.split(/\\s+/), gram)\n    const result = prs.resultsForRule(gram.$root)[0]\n    if (result.action1) {\n        return [result.action1, result.object1]\n    } else {\n        return [result.action2, result.object2]\n    }\n}\n\nconst parseForm = (input: any) => {\n    const gram = loadGrammar(vgGrammar)\n    const prs = parse(input.split(/\\s+/), gram)\n    const result = prs.resultsForRule(gram.$root)[0]\n    return result\n}\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nconst { send, cancel } = actions;\n\nconst boolgrammar: { [index: string]: { yes?: boolean, no?: boolean } } = {\n    \"yes\": { yes: true },\n    \"of course\": { yes: true },\n    \"sure\": { yes: true },\n    \"yeah\": { yes: true },\n    \"no\": { no: false },\n    \"no way\": { no: false },\n    \"nope\": { no: false }\n}\n\nfunction promptAndAsk(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(prompt),\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: [send('LISTEN'), send('MAXSPEECH', { delay: 4000, id: 'maxsp' })]\n            },\n        }\n    })\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'createAppointment'\n            }\n        },\n        createAppointment: {\n            initial: 'who',\n            on: {\n                RECOGNISED: {\n                    target: 'help',\n                    cond: (context) => context.recResult === 'help'\n                },\n                MAXSPEECH: [{ target: 'maxspeech2', cond: (context) => context.counter === 1 },\n                {\n                    target: 'maxspeech3', cond: (context) => context.counter === 2\n                },\n                { target: \"maxspeech1\" }]\n            },\n            states: {\n                hist: { type: 'history' },\n                who: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [{ target: '#root.dm.help', cond: (context) => context.recResult === 'help' },\n                        {\n                            cond: (context) => parseForm(context.recResult).person && !(parseForm(context.recResult).day) && !(parseForm(context.recResult).time),\n                            actions: [assign((context) => { return { person: parseForm(context.recResult).person } }), cancel('maxsp')],\n                            target: \"day\"\n                        },\n                        {\n                            cond: (context) => parseForm(context.recResult).person && parseForm(context.recResult).day && !(parseForm(context.recResult).time),\n                            actions: [assign((context) => { return { day: parseForm(context.recResult).day, person: parseForm(context.recResult).person } }), cancel('maxsp')],\n                            target: \"allday\"\n                        },\n                        {\n                            cond: (context) => parseForm(context.recResult).person && parseForm(context.recResult).day && (parseForm(context.recResult).time === \"all day\"),\n                            actions: [assign((context) => { return { day: parseForm(context.recResult).day, person: parseForm(context.recResult).person, time: parseForm(context.recResult).time } }), cancel('maxsp')],\n                            target: \"schedule_meeting_allday\"\n                        },\n                        {\n                            cond: (context) => parseForm(context.recResult).person && parseForm(context.recResult).day && parseForm(context.recResult).time && (parseForm(context.recResult).time !== \"all day\"),\n                            actions: [assign((context) => { return { day: parseForm(context.recResult).day, person: parseForm(context.recResult).person, time: parseForm(context.recResult).time } }), cancel('maxsp')],\n                            target: \"schedule_meeting\"\n                        },\n                        { target: \".nomatch\" }],\n                    },\n                    states: {\n                        prompt: {\n                            ...promptAndAsk(\"Let's create an appointment! Who are you meeting with?\")\n                        },\n                        nomatch: {\n                            entry: say(\"Sorry I don't know them.\"),\n                            on: { ENDSPEECH: [{ target: \"prompt\", actions: cancel('maxsp') }] }\n                        }\n                    }\n                },\n                day: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [{ target: '#root.dm.help', cond: (context) => context.recResult === 'help' },\n                        {\n                            cond: (context) => context.person && parseForm(context.recResult).day && !(parseForm(context.recResult).time),\n                            actions: [assign((context) => { return { day: parseForm(context.recResult).day} }), cancel('maxsp')],\n                            target: \"allday\"\n                        },\n                        {\n                            cond: (context) => context.person && parseForm(context.recResult).day && (parseForm(context.recResult).time === \"all day\"),\n                            actions: [assign((context) => { return { day: parseForm(context.recResult).day, time: parseForm(context.recResult).time } }), cancel('maxsp')],\n                            target: \"schedule_meeting_allday\"\n                        },\n                        {\n                            cond: (context) => context.person && parseForm(context.recResult).day && parseForm(context.recResult).time && (parseForm(context.recResult).time !== \"all day\"),\n                            actions: [assign((context) => { return { day: parseForm(context.recResult).day, time: parseForm(context.recResult).time } }), cancel('maxsp')],\n                            target: \"schedule_meeting\"\n                        },\n                        { target: \".nomatch\" }],\n                    },\n                    states: {\n                        prompt: {\n                            entry: send((context) => ({\n                                type: \"SPEAK\",\n                                value: `OK. ${context.person}. On which day is your meeting?`\n                            })),\n                            on: { ENDSPEECH: \"ask\" }\n                        },\n                        ask: {\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 4000, id: 'maxsp' })]\n                        },\n                        nomatch: {\n                            entry: say(\"Sorry I didn't catch that. On which day is your meeting?\"),\n                            on: { ENDSPEECH: [{ target: \"ask\", actions: cancel('maxsp') }] }\n                        }\n\n                    }\n                },\n                allday: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [{ target: '#root.dm.help', cond: (context) => context.recResult === 'help' }, {\n                            cond: (context) => \"yes\" in (boolgrammar[context.recResult] || {}),\n                            actions: cancel('maxsp'),\n                            target: \"schedule_meeting_allday\"\n\n                        },\n                        {\n                            cond: (context) => \"no\" in (boolgrammar[context.recResult] || {}),\n                            actions: cancel('maxsp'),\n                            target: \"time\"\n\n                        },\n                        { target: \".nomatch\" }],\n                    },\n                    states: {\n                        prompt: {\n                            entry: send((context) => ({\n                                type: \"SPEAK\",\n                                value: `OK. ${context.day}. Will it take all day?`\n                            })),\n                            on: { ENDSPEECH: \"ask\" }\n                        },\n                        ask: {\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 4000, id: 'maxsp' })]\n                        },\n                        nomatch: {\n                            entry: say(\"Sorry I didn't catch that. Will it take all day?\"),\n                            on: { ENDSPEECH: [{ target: \"ask\", actions: cancel('maxsp') }] }\n                        }\n\n                    }\n                },\n                time: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [{ target: '#root.dm.help', cond: (context) => context.recResult === 'help' }, {\n                            cond: (context) => parseForm(context.recResult).time,\n                            actions: [assign((context) => { return { time: parseForm(context.recResult).time } }), cancel('maxsp')],\n                            target: \"schedule_meeting\"\n\n                        },\n                        { target: \".nomatch\" }],\n                    },\n                    states: {\n                        prompt: {\n                            entry: send((context) => ({\n                                type: \"SPEAK\",\n                                value: `OK. What time is your meeting?`\n                            })),\n                            on: { ENDSPEECH: \"ask\" }\n                        },\n                        ask: {\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 4000, id: 'maxsp' })]\n                        },\n                        nomatch: {\n                            entry: say(\"Sorry I didn't catch that. What time is your meeting?\"),\n                            on: { ENDSPEECH: [{ target: \"ask\", actions: cancel('maxsp') }] }\n                        }\n\n                    }\n                },\n                schedule_meeting_allday: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [{ target: '#root.dm.help', cond: (context) => context.recResult === 'help' }, {\n                            cond: (context) => \"yes\" in (boolgrammar[context.recResult] || {}),\n                            actions: cancel('maxsp'),\n                            target: \"end\"\n\n                        },\n                        {\n                            cond: (context) => \"no\" in (boolgrammar[context.recResult] || {}),\n                            actions: cancel('maxsp'),\n                            target: \"who\"\n\n                        },\n                        { target: \".nomatch\" }],\n                    },\n                    states: {\n                        prompt: {\n                            entry: send((context) => ({\n                                type: \"SPEAK\",\n                                value: `Do you want me to create an appointment with ${context.person} on ${context.day}?`\n                            })),\n                            on: { ENDSPEECH: \"ask\" }\n                        },\n                        ask: {\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 4000, id: 'maxsp' })]\n                        },\n                        nomatch: {\n                            entry: say(\"Sorry I didn't catch that\"),\n                            on: { ENDSPEECH: [{ target: \"ask\", actions: cancel('maxsp') }] }\n                        }\n\n                    }\n                },\n                schedule_meeting: {\n                    initial: \"prompt\",\n                    on: {\n                        RECOGNISED: [{ target: '#root.dm.help', cond: (context) => context.recResult === 'help' }, {\n                            cond: (context) => \"yes\" in (boolgrammar[context.recResult] || {}),\n                            actions: cancel('maxsp'),\n                            target: \"end\"\n\n                        },\n                        {\n                            cond: (context) => \"no\" in (boolgrammar[context.recResult] || {}),\n                            actions: cancel('maxsp'),\n                            target: \"who\"\n\n                        },\n                        { target: \".nomatch\" }],\n                    },\n                    states: {\n                        prompt: {\n                            entry: send((context) => ({\n                                type: \"SPEAK\",\n                                value: `Do you want me to create an appointment with ${context.person} on ${context.day} at ${context.time}?`\n                            })),\n                            on: { ENDSPEECH: \"ask\" }\n                        },\n                        ask: {\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 4000, id: 'maxsp' })]\n                        },\n                        nomatch: {\n                            entry: say(\"Sorry I didn't catch that\"),\n                            on: { ENDSPEECH: [{ target: \"ask\", actions: cancel('maxsp') }] }\n                        }\n\n                    }\n                }, end: {\n                    initial: \"prompt\",\n                    states: {\n                        prompt: {\n                            entry: say(\"Your appointment has been created.\"),\n                            on: { ENDSPEECH: \"#root.dm\" }\n                        }\n                    }\n                }\n\n\n\n            }\n        },\n        maxspeech1: {\n            entry: say(\"I couldn't hear you.\"),\n            on: {\n                ENDSPEECH: [{ target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 1 },\n                { target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 2 },\n                { target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 3 }],\n            }\n        },\n        maxspeech2: {\n            entry: say(\"Are you there?\"),\n            on: {\n                ENDSPEECH: [{ target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 1 },\n                { target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 2 },\n                { target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 3 }],\n            }\n        },\n        maxspeech3: {\n            entry: say(\"You're not even listening, I give up.\"),\n            on: {\n                ENDSPEECH: [{ target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 1 },\n                { target: \"#root.dm.createAppointment.hist\", cond: (context) => context.counter === 2 },\n                { target: \"#root.dm\", cond: (context) => context.counter === 3 }],\n            }\n        },\n        help: {\n            initial: \"prompt\",\n            states: {\n                prompt: {\n                    entry: say(\"Help message.\"),\n                    on: { ENDSPEECH: \"#root.dm.createAppointment.hist\" }\n                }\n            }\n        }\n    }\n})\n\nexport const dmMachine2: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n        welcome: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [{\n                    actions: [assign((context) => { return { action: getObjects(context.recResult)[0] } }),\n                    assign((context) => { return { object: getObjects(context.recResult)[1] } })],\n                    target: \"confirm\"\n                }]\n            },\n            states: {\n                prompt: {\n                    entry: say(\"What would you like to do?\"),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                }\n            }\n        },\n        confirm: {\n            entry: send((context) => ({\n                type: \"SPEAK\",\n                value: `OK. I will ${context.action} the ${context.object}.`\n            })),\n            on: { ENDSPEECH: \"init\" }\n        }\n    }\n})","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, send, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine } from \"./dmAppointmentVG\";\n\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\nlet count = 0\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMachine\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                recognising: {\n                    initial: 'progress',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        MAXSPEECH: {\n                            actions: assign((context) => {\n                                if (context.counter) {\n                                    return { counter: context.counter + 1 }\n                                } else {\n                                    return { counter: count + 1 }\n                                }\n                            }),\n                            target: 'idle'\n                        },\n                    },\n                    states: {\n                        progress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a command.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            changeColour: asEffect((context) => {\n                console.log('Repainting...');\n                document.body.style.background = context.recResult;\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n            /* speak: asEffect((context) => {\n         * console.log('Speaking...');\n             *     speak({text: context.ttsAgenda })\n             * } */\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://lab-ii.herokuapp.com/model/parse'\nexport const nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://localhost:3000/react-xstate-colourchanger' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n","//\n//  srgs.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n//////////////////////////////////////////////////////////////////////\n// encoding SRGS grammars in javascript\n\nexport function Grammar(root) {\n    this.$root = root;\n\n    this.VOID = [OneOf([])];\n    this.NULL = [];\n    this.GARBAGE = [];\n\n    this.$check = function () {\n        for (var i in this) {\n            if (i !== \"$root\" && i !== \"$check\") {\n                try {\n                    checkSequenceExpansion(this[i]);\n                } catch (err) {\n                    throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\n                }\n            }\n        }\n    }\n}\n\nexport function WordSet(str) {\n    var words = str.split(/ +/);\n    var set = {};\n    for (var i in words) {\n        set[words[i]] = true;\n    }\n    return set;\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion constructors\n\n// sequences are ordinary arrays\nexport function Sequence(seq) {\n    return seq;\n}\n\nexport function Ref(ref) {\n    return new RefClass(ref);\n}\n\nexport function Tag(tag) {\n    return new TagClass(tag);\n}\n\nexport function OneOf(alternatives) {\n    return new OneOfClass(alternatives);\n}\n\nexport function Repeat(min, max, sequence) {\n    return new RepeatClass(min, max, sequence);\n}\n\nexport function Optional(sequence) {\n    return new RepeatClass(0, 1, sequence);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion classes\n\nexport function RefClass(ruleref) {\n    this.content = ruleref;\n    this._string = \"$\" + ruleref;\n    this.toString = function toString() { return this._string }\n}\n\nexport function TagClass(tag) {\n    this.content = tag;\n    this._string = \"{\" + tag + \"}\";\n    this.toString = function toString() { return this._string }\n}\n\nexport function OneOfClass(alternatives) {\n    this.content = alternatives;\n    this._string = \"(\" + alternatives.join(\"|\") + \")\";\n    this.toString = function toString() { return this._string }\n}\n\nexport function RepeatClass(min, max, sequence) {\n    this.min = min;\n    this.max = max;\n    this.content = sequence;\n    this._string = this.content + \"<\" + this.min + \"-\" + (this.max == Infinity ? \"\" : this.max) + \">\"\n    this.toString = function toString() { return this._string }\n}\n\n//////////////////////////////////////////////////////////////////////\n// checking rule expansions\n\nexport function throwRuleError(message, error) {\n    if (error == undefined) {\n        throw TypeError(message);\n    } else {\n        throw TypeError(message + \"; \" + error.message);\n    }\n}\n\nexport function checkSequenceExpansion(sequence) {\n    try {\n        if (sequence.constructor !== Array) {\n            throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\n        }\n        for (var i in sequence) {\n            if (sequence[i].constructor == Array) {\n                checkSequenceExpansion(sequence[i]);\n            } else if (sequence[i].constructor != String) {\n                sequence[i].checkExpansion();\n            }\n        }\n    } catch (err) {\n        throwRuleError(\"When checking sequence expansion\", err);\n    }\n};\n\nRefClass.prototype.checkExpansion = function checkExpansion() {\n    if (this.content.constructor !== String) {\n        throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\n    }\n};\n\nTagClass.prototype.checkExpansion = function checkExpansion() {\n    if (this.content.constructor !== String) {\n        throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\n    }\n};\n\nOneOfClass.prototype.checkExpansion = function checkExpansion() {\n    try {\n        if (this.content.constructor !== Array) {\n            throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\n        }\n        for (var i in this.content) {\n            checkSequenceExpansion(this.content[i]);\n        }\n    } catch (err) {\n        throwRuleError(\"When checking OneOf content\", err);\n    }\n};\n\nRepeatClass.prototype.checkExpansion = function checkExpansion() {\n    try {\n        if (this.min.constructor !== Number || this.max.constructor !== Number) {\n            throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\n        }\n        if (!(0 <= this.min && this.min <= this.max)) {\n            throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\n        }\n        checkSequenceExpansion(this.content);\n    } catch (err) {\n        throwRuleError(\"When checking Repeat content\", err);\n    }\n};"],"sourceRoot":""}